import type { ReleaserStepsOptions, Project, GitRepositoryHosting, ReleaserOptions } from '@simple-release/core';
export interface SimpleReleaseConfig<P extends Project = Project, G extends GitRepositoryHosting = GitRepositoryHosting> extends ReleaserStepsOptions<P, G> {
    project?: P;
    hosting?: G;
    releaser?: Omit<ReleaserOptions, 'project' | 'hosting'>;
}
export type SimpleReleaseConfigRequirements = {
    config?: boolean;
} & {
    [K in keyof SimpleReleaseConfig]?: boolean;
};
type ApplyRequirements<T extends Record<string, any>, R extends Record<string, any>> = {
    [K in keyof T as K extends keyof R ? R[K] extends true ? K : never : never]-?: Exclude<T[K], undefined>;
} & {
    [K in keyof T as K extends keyof R ? R[K] extends true ? never : K : K]: T[K];
};
type ApplyConfigRequirement<R extends {
    config?: boolean;
}, T> = R extends {
    config: true;
} ? T : T | null;
type Result<P extends Project = Project, G extends GitRepositoryHosting = GitRepositoryHosting, R extends SimpleReleaseConfigRequirements = SimpleReleaseConfigRequirements> = ApplyRequirements<SimpleReleaseConfig<P, G>, R> extends infer C ? ApplyConfigRequirement<R, C> : never;
/**
 * Load simple-release config.
 * @param requirements
 * @returns simple-release config
 */
export declare function load<P extends Project = Project, G extends GitRepositoryHosting = GitRepositoryHosting, R extends SimpleReleaseConfigRequirements = SimpleReleaseConfigRequirements>(requirements?: R): Promise<Result<P, G, R>>;
export {};
//# sourceMappingURL=index.d.ts.map