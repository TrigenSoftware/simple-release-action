/* eslint-disable no-labels */
import { createReadStream, createWriteStream } from 'fs';
import fs from 'fs/promises';
import { tmpfile, isFileExists } from './utils.js';
const versionHeaderRegex = /^#+ \[?([^[\]()\s]*\d+\.\d+\.\d+[^[\]()\s]*)\]?/m;
const tagsRegex = /\/([^/)]*)\.\.\.([^/)]*)\)/;
export const changelogHeader = `# Changelog

All notable changes to this project will be documented in this file.
See [Conventional Commits](https://conventionalcommits.org) for commit guidelines.

`;
/**
 * Add release notes to a changelog file.
 * @param changelogPath - The path to the changelog file.
 * @param notes - An async iterable of strings representing the release notes.
 * @returns The release notes that were added to the changelog.
 */
export async function addReleaseNotes(changelogPath, notes) {
    const tmpChangelogPath = tmpfile('changelog');
    const isNewFile = !await isFileExists(changelogPath);
    const output = createWriteStream(tmpChangelogPath);
    let changes = '';
    if (isNewFile) {
        output.write(changelogHeader);
        for await (const chunk of notes) {
            output.write(chunk);
            changes += chunk;
        }
    }
    else {
        const input = createReadStream(changelogPath);
        let isHeader = true;
        let chunk;
        for await (chunk of input) {
            chunk = chunk.toString();
            if (isHeader) {
                const headerIndex = chunk.search(versionHeaderRegex);
                if (headerIndex !== -1) {
                    isHeader = false;
                    output.write(chunk.slice(0, headerIndex));
                    chunk = chunk.slice(headerIndex);
                    for await (const chunk of notes) {
                        output.write(chunk);
                        changes += chunk;
                    }
                    output.write('\n');
                }
            }
            output.write(chunk);
        }
        await fs.rm(changelogPath);
    }
    await new Promise(output.end.bind(output));
    await fs.rename(tmpChangelogPath, changelogPath);
    return changes;
}
/**
 * Extract the last release notes from a stream.
 * @param input
 * @returns An object containing the release notes, previous tag, and next tag.
 */
export async function extractLastRelease(input) {
    let stream = input;
    let inLastChanges = false;
    let notes = '';
    let chunk;
    let lines;
    let line;
    let previousTag = '';
    let nextTag = '';
    let version = '';
    if (typeof stream === 'string') {
        stream = [stream];
    }
    top: for await (chunk of stream) {
        lines = chunk.toString('utf8').split(/\n/);
        for (line of lines) {
            const versionMatch = line.match(versionHeaderRegex);
            if (versionMatch) {
                if (inLastChanges) {
                    break top;
                }
                [, version] = versionMatch;
                inLastChanges = true;
                const tagsMatch = line.match(tagsRegex);
                if (tagsMatch) {
                    [
                        ,
                        previousTag,
                        nextTag
                    ] = tagsMatch;
                }
                continue;
            }
            if (inLastChanges) {
                notes += `${line}\n`;
            }
        }
    }
    return {
        version,
        notes: notes.trim(),
        previousTag,
        nextTag
    };
}
/**
 * Extract the last release notes from a changelog file.
 * @param changelogPath - The path to the changelog file.
 * @returns An object containing the release notes, previous tag, and next tag.
 */
export async function extractLastReleaseFromFile(changelogPath) {
    if (!await isFileExists(changelogPath)) {
        return null;
    }
    const input = createReadStream(changelogPath);
    return await extractLastRelease(input);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhbmdlLWxvZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jaGFuZ2UtbG9nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDhCQUE4QjtBQUM5QixPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLGlCQUFpQixFQUNsQixNQUFNLElBQUksQ0FBQTtBQUNYLE9BQU8sRUFBRSxNQUFNLGFBQWEsQ0FBQTtBQUM1QixPQUFPLEVBQ0wsT0FBTyxFQUNQLFlBQVksRUFDYixNQUFNLFlBQVksQ0FBQTtBQUVuQixNQUFNLGtCQUFrQixHQUFHLGtEQUFrRCxDQUFBO0FBQzdFLE1BQU0sU0FBUyxHQUFHLDRCQUE0QixDQUFBO0FBRTlDLE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRzs7Ozs7Q0FLOUIsQ0FBQTtBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxDQUFDLEtBQUssVUFBVSxlQUFlLENBQ25DLGFBQXFCLEVBQ3JCLEtBQTRCO0lBRTVCLE1BQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFBO0lBQzdDLE1BQU0sU0FBUyxHQUFHLENBQUMsTUFBTSxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUE7SUFDcEQsTUFBTSxNQUFNLEdBQUcsaUJBQWlCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtJQUNsRCxJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUE7SUFFaEIsSUFBSSxTQUFTLEVBQUUsQ0FBQztRQUNkLE1BQU0sQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUE7UUFFN0IsSUFBSSxLQUFLLEVBQUUsTUFBTSxLQUFLLElBQUksS0FBSyxFQUFFLENBQUM7WUFDaEMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQTtZQUNuQixPQUFPLElBQUksS0FBSyxDQUFBO1FBQ2xCLENBQUM7SUFDSCxDQUFDO1NBQU0sQ0FBQztRQUNOLE1BQU0sS0FBSyxHQUFHLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxDQUFBO1FBQzdDLElBQUks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